var documenterSearchIndex = {"docs":
[{"location":"man/intro/#intro","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro.md\"]\nDepth = 2","category":"page"},{"location":"man/intro/#spharms-defn","page":"Introduction","title":"Definition","text":"","category":"section"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"The spherical harmonics Y_ell^m(thetaphi) arise from solving Laplace's equation","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign\n    nabla^2 psi = 0\nendalign","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"in spherical coordinates. The equation is separable into a radial component R(r) and an angular part Y(thetaphi) such that the total solution is psi(rthetaphi) equiv R(r)Y(thetaphi). We ignore the radial component and continue with only the angular part.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"The second-order differential equation for the angular component, written in the standard physicists' form where theta is the colatitude and phi the azimuth angles, is","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign\n    frac1sintheta fracpartialpartialtheta\n        left( sintheta fracpartialpartialtheta Y right)\n        + frac1sin^2theta fracpartial^2partialphi^2 Y\n        + ell(ell+1) Y = 0\nendalign","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"The differential equation is further separable among the two angular coordinates, with the result being a family of solutions parameterized by the integer constants ell  0 and m  ell. Including normalization factors[norm], the spherical harmonics Y_ell m(thetaphi) can be written as","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign\n    Y_ell m(theta phi) equiv\n        sqrtfrac2ell+14pi frac(ell-m)(ell+m)\n        P_ell^m(costheta)  e^imphi\n    = lambda_ell^m(costheta)  e^imphi\nendalign","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"where lambda_ell^m(costheta) are pre-normalized Associated Legendre Polynomials for spherical harmonic transforms (see AssociatedLegendrePolynomials.jl) and e^imphi are the complex exponentials.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"[norm]: Be aware that there are multiple conventions for how to define the spherical harmonics that differ in the details of the normalization factors. For instance, the so-called Condon-Shortley phase factor of (-1)^m can either be omitted entirely, included as an explicit term in the normalization of the spherical harmonics, or included as an explicit symmetry in the definition of the Legendre polynomials. We use this last option here, which is also consistent with typical physicists' experience in e.g. Classical Electrodynamics by J.D. Jackson. See also Abramowitz & Stegun.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"The spherical harmonics are a complete, orthonormal basis for functions on the sphere (thetaphi) in mathbbS = 0pitimes02pi. Therefore they satisfy the condition that","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign*\n    int_mathbbS Y_ell m(thetaphi) Y_ell m(thetaphi)\n        dOmega = delta_ellell delta_mm\nendalign*","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"where dOmega = sintheta dthetadphi.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"It then follows that an arbitrary function on the sphere f(thetaphi) can be harmonically decomposed into an ensemble of coefficients a_ell m:","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign\n    a_ell m = int_mathbbS f(theta phi) overlineY_ell m(thetaphi) dOmega\nendalign","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"where the overline on overlineY_ell m denotes complex conjugation. The function is (re)synthesized from the a_ell ms as the linear combination of the spherical harmonics:","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign\n    f(thetaphi) = sum_ell=0^ell_mathrmmax\n        sum_m=-ell^ell a_ell m Y_ell m(thetaphi)\n        labeleqncomplex_synthesis\nendalign","category":"page"},{"location":"man/intro/#Real-Symmetries","page":"Introduction","title":"Real Symmetries","text":"","category":"section"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"In general, f may be a complex function (i.e. f  mathbbS rightarrow mathbbC), but if it is a real function (f  mathbbS rightarrow mathbbR), then there are some additional symmetries of note.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"First, due to an underlying property of the Associated Legendre polynomials, the negative orders (m  0) are related to the positive orders according to","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign\n    Y_ell (-m)(thetaphi) = (-1)^m overlineY_ell (+m)(thetaphi)\nendalign","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Given this relationship between the positive and negative orders, the harmonic coefficients have a similar property as well, with","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign\n    a_ell(-m) = (-1)^m overlinea_ell(+m)\nendalign","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"This directly constraints the order m = 0 modes to being real coefficients since x = overline x if and only if x is real. Furthermore, this permits the synthesis to be performed using a sum over the range of integers m = 0 ell instead of -ell ell because by pairwise summing the postive and negative orders with each other, we find:","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign*\n    a_ell(-m) Y_ell (-m) + a_ell(+m) Y_ell (+m) =\n        (-1)^m overlinea_ell(+m) cdot (-1)^m overlineY_ell (+m) +\n        a_ell(+m) Y_ell (+m) \n     = overlinea_ell(+m) Y_ell (+m) + a_ell(+m) Y_ell (+m) \n     = 2 operatornameReleft a_ell(+m) Y_ell (+m) right\nendalign*","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Note that this excludes the m = 0 cases which have no pair so there needs to be an extra multiplicity factor in the summation — for instance, choosing a notation that uses the Kronecker delta, (2-delta_m0) = begincases 1  textif  m=0  2  textotherwise endcases, and","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign\n    f(thetaphi) = sum_ell=0^ell_mathrmmax\n        sum_m=0^ell (2 - delta_m0) a_ell m Y_ell m(thetaphi)\nendalign","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"A similar argument applies to harmonic analysis of a field into the a_ell m coefficients except there is no need for an extra multiplicity factor; instead you simply run the integration for only the non-negative orders.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"The second useful symmetry is that the Legendre polynomials are even/odd for even/odd combinations of orders and degrees, so the spherical harmonics inherit the even/odd symmetry across the equator:","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign\n    P_ell^m(-z) = (-1)^ell+m P_ell^m(z)\n    quadRightarrowquad\n    Y_ell m(pi - theta phi) = (-1)^ell+m Y_ell m(thetaphi)\nendalign","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"This is a useful property when it comes to designing pixelization schemes on the sphere since symmetry over the equator allows for reuse in the calculation of Legendre polynomials for pairs of latitudes with only a much [computationally] cheaper negation required of one of half of the pair.","category":"page"},{"location":"man/intro/#FFT-based-Ring-Transforms","page":"Introduction","title":"FFT-based Ring Transforms","text":"","category":"section"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"If the sphere is discretized by a series of isolatitude rings, each of which are comprised of uniformly-spaced pixels in azimuth, then the fast Fourier transform (FFT) may be employed to reduce the computational complexity of the transform.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Starting from Eqn. refeqncomplex_synthesis, changing the order of summation so that the sums over degrees ell are done before the order m reveals the inner summation in a form which corresponds to a discrete Fourier transform.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign*\n    defellmaxell_mathrmmax\n    f(thetaphi) = sum_m=-ellmax^ellmax\n        left sum_ell=m^ellmax a_ell m lambda_ell^m(costheta) right\n        e^imphi\nendalign*","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Then for uniformly spaced pixels in the ring, the azimuth coordinates are","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign*\n    phi_k = phi_0 + frac2pi kN_phi\nendalign*","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"where phi_0 is the offset of the first pixel in the ring away from phi = 0, N_phi is the number of pixels in the ring, and k is an integer in 0 N_phi - 1. Combined with the reordered summation, the expression can be rewritten as","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"beginalign*\n    defellmaxell_mathrmmax\n    f(thetaphi_k) = sum_m=-ellmax^ellmax g_m e^2pi imkN_phi\n    textwhere \n        g_m equiv e^imphi_0 sum_ell=m^ellmax a_ell m lambda_ell^m(costheta)\nendalign*","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"The summation on the left is discrete Fourier transform of the coefficients g_m. When N_phi = 2ellmax + 1, the correspondance to the FFT is exact, and f(theta phi_k) = mathcalF^-1(g_m), using FFTW's sign convention and mathcalF and mathcalF^-1 are the foward and inverse FFT operations, respectively. Also recall that \"negative frequencies\" are just a matter of interpretation and are equivalent to a higher positive frequency one period later. For instance, the m = -1 term is equivalent in the Fourier transform to the (N_phi - 1)-th Fourier frequency.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"For cases when N_phi neq 2ellmax + 1, the summation must be properly zero-padded or alias-truncated — for further details, see Notes on Calculating the Spherical Harmonics (Spherical Harmonics Series, Part I).","category":"page"},{"location":"man/devdocs/#Developer-Documentation","page":"Developer Documentation","title":"Developer Documentation","text":"","category":"section"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"CurrentModule = SphericalHarmonicTransforms\nDocTestFilters = Regex[\n        r\"Ptr{0x[0-9a-f]+}\",\n        r\"[0-9\\.]+ seconds( \\(.*\\))?\",\n        ]","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Pages = [\"devdocs.md\"]\nDepth = 2","category":"page"},{"location":"man/devdocs/#pixelnew","page":"Developer Documentation","title":"Adding New Pixelizations","text":"","category":"section"},{"location":"man/devdocs/#pixelproperties","page":"Developer Documentation","title":"Necessary Properties of Ring-based Pixelizations","text":"","category":"section"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"As the name \"ring-based pixelizations\" suggests, the first obvious requirement for supported pixelization schemes is that the format be describable in terms of isolatitude rings. This restriction greatly reduces the number of times the associated Legendre polynomials must be calculated — from (in principle) every pixel if they all have a unique latitude to only once per isolatitude ring. Therefore, the first per-ring parameter we must be told is the colatitude theta of each ring.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"The second requirement is that each isolatitude ring's pixels meet the necessary conditions for the Fast Fourier Transform (FFT) to be used — namely, the pixels in azimuth are uniformly spaced and span (exactly) a full 2pi radians. These conditions are met when the azimuth coordinates are at locations phi_k = phi_0 + 2pi k  N_phi (for integer index k = 0 1 ldots N_phi - 1), and therefore two additional parameters must be given: the number of pixels within the ring N_phi and the azimuth offset of the first pixel in the ring phi_0. For numerical efficiency and accuracy reasons, we will instead use the azimuth offset divided by pi: phi_0pi.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"These three parameters (theta, N_phi, phi_0) are sufficient for implementing the synthesis transform of a single isolatitude ring. For the analysis transform, though, we also require the integration volume element dOmega equiv sintheta  dtheta  dphi, or rather its finite approximation DeltaOmega approx sintheta  Deltatheta  Deltaphi. Taking the volume element DeltaOmega as a required parameter, the quantity sintheta is never calculated explicitly; instead only costheta is used as the argument of the associated Legendre polynomials, so we can actually also revise the first parameter to instead be the cosine of the colatitude angle costheta.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Together, this gives us 4 parameters which are required to sufficiently describe the geometry of an isolatitude ring so that we can perform spherical harmonic transforms on it:","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"The cosine of the ring's colatitude angle: costheta\nThe azimuth angle, divided by pi, of the first pixel in the ring: phi_0pi\nThe number of pixels equally spaced in azimuth within the ring: N_phi\nThe surface area of each pixel within the ring: DeltaOmega","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"What remains is to describe how multiple rings are assembled into a map that covers the sphere, and here again the ECP grid proves a useful case study. The ECP grid maps well to a matrix (2D array, where colatitude increases across rows and azimuth across columns), but there is an inherent ambiguity in whether the ordering of the matrix in memory is row-major or column-major. If we choose one — say column-major order, consistent with Julia's matrix representation — then the contents of a given isolatitude ring are non-contiguous in memory. One option would be to require that the transpose of the ECP map matrix be used (so that a ring is a contiguous vector of elements), but another more flexible option is to instead make the stride s of the array an additional ring description parameter. When paired with offset of the first pixel in the ring o, we have sufficient information to completely describe an ECP grid in either row- or column-major order.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"As one final optimization, though, recall that if the pixel grid is symmetric over the equator, then rings are best considered in pairs, since the associated Legendre polynomials are the same up to a negative sign for colatitude angles theta and pi - theta. If we replace the single parameter o with a tuple of parameters (o_1 o_2), we can inform our implementation explicitly whether the ring-pair optimization applies (such as for a north-south pair of rings) or not (like for the singular equatorial row) by encoding either two or one valid indices in the tuple, respectively.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Finally, we add these three additional parameters to the above list:","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Offset to the first pixel in the northern- and southern-hemisphere rings, respectively (if valid): (o_1 o_2)\nThe stride across the map array between successive pixels within the ring: s","category":"page"},{"location":"man/devdocs/#pixelinterface","page":"Developer Documentation","title":"Pixelization Interface","text":"","category":"section"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Required","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Interfaces to extend/implement Brief description\nAbstractRingPixelization Supertype of ring-based map pixelizations\nrings() Returns an indexable container of Ring descriptions for each ring in the described map","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Optional Overrides","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"The following functions have a generic implementation which deduces the necessary values by inspecting every ring (returned by rings), but a particular pixelization is encouraged to specialize these if they can be calculated more efficiently using structural knowledge of the pixelization.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Interfaces to extend/implement Brief description\nbuffer() Returns an array compatible with storing a map described by a given ring pixelization\nnring() The number of isolatitude rings in the pixelization\nnpix() The total number of pixels in the pixelization\nnϕmax() The number of pixels in the longest isolatitude ring in the pixelization","category":"page"},{"location":"man/devdocs/#pixelexample","page":"Developer Documentation","title":"Example Implementation","text":"","category":"section"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"using SphericalHarmonicTransforms\nusing SphericalHarmonicTransforms: ECPPixelization","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"The built-in ECP pixelization does not support exact quadrature on the sphere, but it is included because the axes are uniformly sampled (so the maps are easily represented as matrices without any special handling) and the simplicity of its implementation. For more than trivial or example cases, though, it is very likely that another pixelization scheme will be required.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"A well-known improvement is to modify the ECP grid to permit non-uniformly sampled points in theta, with the node locations (and weights, see below) corresponding to the Gauss-Legendre nodes. In this section, we will demonstrate implementing support for spherical harmonic transforms on the the Gauss-Legendre (GL) pixelization. Computation of the Gauss-Legendre nodes and weights is provided by FastGaussQuadrature.jl.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"The first step is to import the interface types. The new GLPixelization type must be a subclass of the AbstractRingPixelization, where the type parameter R is the nominal element type used during the transform.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"import SphericalHarmonicTransforms: AbstractRingPixelization, Ring,\n        rings, buffer, nring, npix, nϕmax\nstruct GLPixelization{R} <: AbstractRingPixelization{R}\n    nθ::Int\n    nϕ::Int\nend\nGLPixelization(nθ, nϕ) = GLPixelization{Float64}(nθ, nϕ)","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Then, the only other required step is to implement a specialization of the rings method to return a vector of Ring structures that describe the properties of the ring.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"using FastGaussQuadrature: gausslegendre\nfunction rings(glpix::GLPixelization{R}) where {R}\n    nθ, nϕ = glpix.nθ, glpix.nϕ\n    nθh = (nθ + 1) ÷ 2  # number of rings in N. hemisphere + equator (if nθ is odd)\n    ϕ_π = one(R) / nϕ   # constant pixel offset for all rings\n    Δϕ = 2R(π) / nϕ     # constant azimuthal pixel size for all rings\n    stride = nθ         # constant stride, column-major ordering\n    cθ, sθΔθ = gausslegendre(nθ)  # z = cos(θ) and corresponding weights\n    # z ∈ [-1, 1] and θ ∈ [0, π] run in opposite directions, but cos(θ) == -z\n    cθ = -cθ[1:nθh]\n    sθΔθ = sθΔθ[1:nθh]\n    rings = Vector{Ring}(undef, nθh)\n    for ii in 1:nθh\n        o₁ = ii           # northern-ring offset\n        o₂ = nθ - ii + 1  # southern-ring offset\n        offs = (o₁, o₁ == o₂ ? 0 : o₂)  # pairs, except if both aligned with equator\n        rings[ii] = Ring(offs, stride, nϕ, cθ[ii], ϕ_π, sθΔθ[ii] * Δϕ)\n    end\n    return rings\nend","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"With just rings implemented, generic methods will then calculate other necessary parameters by inspecting the ring list.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"For example, we can observe that the Gauss-Legendre grid has better properties with respect to the finite integration when compared to the ECP grid.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"alms = zeros(ComplexF64, 6, 6); alms[3, 1] = 1;  # a_{20} = 1\necppix, glpix = ECPPixelization(50, 100), GLPixelization(50, 100);\necpmap, glmap = synthesize(ecppix, alms), synthesize(glpix, alms);\nanalyze(ecppix, ecpmap, #=lmax=# 5)\nanalyze(glpix, glmap, #=lmax=# 5)","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Notice that the ECP grid analysis \"leaks\" power into neighboring spherical harmonic coefficients, but the GL grid almost exactly recovers the input coefficients.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Returning to the optional components of abstract pixelization interface, compare the shapes of the two maps created above:","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"size(ecpmap)\nsize(glmap)","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Like the ECP grid, it may be preferable to conceptualize and represent the GL grid as a matrix rather than a vector. (Fundamentally, the shape of the array is immaterial to synthesize and analyze, as long as the described ring pixelization is within bounds of the array's linear indices.) Overloading the buffer function provides a mechanism to allocate the synthesize map with a preferred shape:","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"function buffer(glpix::GLPixelization, ::Type{T}) where {T}\n    return Matrix{T}(undef, glpix.nθ, glpix.nϕ)\nend\nsize(synthesize(glpix, alms))","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"note: Note\nBe sure to overload the 2-argument method which explicitly takes the descired element type. The 1-argument method will forward the pixelization's type parameter as the second argument if necessary.","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"The other reason to implement specializations of the optional interface is that generic methods infer the necessary pixelization properties by iterating through the list of all rings and extracting/calculating the relevant quantites. We can see this quite obviously as memory allocations when running these functions, despite the grid size alone provides all the necessary information (and therefore should not require actually allocating the rings vector):","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"(nring(glpix), npix(glpix), nϕmax(glpix)); # warmup\n@time (nring(glpix), npix(glpix), nϕmax(glpix))","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"By overloading specializations for the GLPixelization type,","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"nring(glpix::GLPixelization) = glpix.nθ\nnpix(glpix::GLPixelization) = glpix.nθ * glpix.nϕ\nnϕmax(glpix::GLPixelization) = glpix.nϕ","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"we can avoid such unnecessary computation and allocation:","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"(nring(glpix), npix(glpix), nϕmax(glpix)); # warmup\n@time (npix(glpix), nϕmax(glpix))","category":"page"},{"location":"man/devdocs/","page":"Developer Documentation","title":"Developer Documentation","text":"(where the remaining allocation is due to the returned tuple of values).","category":"page"},{"location":"lib/public/","page":"API Reference","title":"API Reference","text":"CurrentModule = SphericalHarmonicTransforms","category":"page"},{"location":"lib/public/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"lib/public/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"lib/public/","page":"API Reference","title":"API Reference","text":"synthesize\nsynthesize!","category":"page"},{"location":"lib/public/#SphericalHarmonicTransforms.synthesize","page":"API Reference","title":"SphericalHarmonicTransforms.synthesize","text":"mapbuf = synthesize(ringpix::AbstractRingPixelization, alms::AbstractMatrix{<:Complex})\n\nPerforms the spherical harmonic synthesis transform of the harmonic coefficients alms for a real-valued map mapbuf, pixelized as described by ringpix.\n\nSee also synthesize!, analyze, analyze!\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SphericalHarmonicTransforms.synthesize!","page":"API Reference","title":"SphericalHarmonicTransforms.synthesize!","text":"synthesize!(mapbuf::AbstractArray{<:Real}, ringpix::AbstractRingPixelization, alms::AbstractMatrix{<:Complex})\n\nPerforms the spherical harmonic synthesis transform of the harmonic coefficients alms for a real-valued map mapbuf, pixelized as described by ringpix.\n\nSee also synthesize, analyze, analyze!\n\nExtended help\n\nThe synthesis transform is implemented such that a real-valued function f(θ ϕ) is generated from complex-valued spherical harmonic coefficients a_ℓm as\n\n    f(θ ϕ) = sum_ℓ=0^ℓ_mathrmmax sum_m=0^ℓ a_ℓm Y_ℓm(θ ϕ)\n\nwhere the a_ℓms matrix contains only the non-negative orders (m  0) since the negative orders are not independent when f(θ ϕ) is real.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/","page":"API Reference","title":"API Reference","text":"analyze\nanalyze!","category":"page"},{"location":"lib/public/#SphericalHarmonicTransforms.analyze","page":"API Reference","title":"SphericalHarmonicTransforms.analyze","text":"alms = analyze(ringpix::AbstractRingPixelization, mapbuf::AbstractArray{<:Real}, lmax::Integer, mmax::Integer = lmax)\n\nPerforms the spherical harmonic analysis transform of the real-valued map mapbuf, pixelized as described by ringpix, to the corresponding complex-valued spherical harmonic coefficients alms.\n\nSee also analyze!, synthesize, synthesize!\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SphericalHarmonicTransforms.analyze!","page":"API Reference","title":"SphericalHarmonicTransforms.analyze!","text":"analyze!(alms::AbstractMatrix{<:Complex}, ringpix::AbstractRingPixelization, mapbuf::AbstractAray{<:Real})\n\nPerforms the discrete spherical harmonic analysis transform of the real-valued map mapbuf, pixelized as described by ringpix, to the corresponding complex-valued spherical harmonic coefficients alms.\n\nSee also analyze, synthesize, synthesize!\n\nExtended help\n\nThe analysis transform is implemented such that a real-valued function f(θ ϕ) is analyzed for its corresponding complex-valued spherical harmonic coefficients a_ℓm as\n\n    a_ℓm = sum_ℓ=0^ℓ_mathrmmax sum_m=0^ℓ f(θ ϕ) overlineY_ℓm(θ ϕ) ΔΩ\n\nwhere the overline indicates complex conjugation, ΔΩ is the integration element (pixel area) on the sphere, and the a_ℓms matrix contains only the non-negative orders (m  0) since the negative orders are not independent when f(θ ϕ) is real.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Ring-based-Pixelizations","page":"API Reference","title":"Ring-based Pixelizations","text":"","category":"section"},{"location":"lib/public/#Pixelizations","page":"API Reference","title":"Pixelizations","text":"","category":"section"},{"location":"lib/public/","page":"API Reference","title":"API Reference","text":"RingPixelization\nECPPixelization","category":"page"},{"location":"lib/public/#SphericalHarmonicTransforms.RingPixelization","page":"API Reference","title":"SphericalHarmonicTransforms.RingPixelization","text":"RingPixelization{R} <: AbstractRingPixelization{R}\n\nA pixelization of the unit sphere described by an arbitrary vector of Rings.\n\nExamples\n\njulia> ringpix = RingPixelization(ECPPixelization(5, 10))\n5-ring RingPixelization{Float64} with 50 pixels\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SphericalHarmonicTransforms.ECPPixelization","page":"API Reference","title":"SphericalHarmonicTransforms.ECPPixelization","text":"ECPPixelization{R} <: AbstractRingPixelization{R}\n\nAn Equidistant Cylindrical Projection pixelization in column-major order, with dimensions nθ × nϕ in the colatitude/azimuth directions, respectively.\n\nSee also RingPixelization\n\nExamples\n\njulia> ECPPixelization(250, 500)\n250×500 ECPPixelization{Float64}\n\njulia> ECPPixelization{Float32}(250, 500)\n250×500 ECPPixelization{Float32}\n\nExtended help\n\nThe described pixelization covers the entire sphere 0 π  0 2π with uniformly-sized pixels in coordinate space of size Δθ = πn_θ by Δϕ = 2πn_ϕ. The pixel centers take on coordinates\n\n    (θ_j ϕ_k) = left( π frac2j + 12n_θ 2π frac2k + 12n_ϕ right)\n\nfor integers j  0  n_θ - 1 and k  0  n_ϕ - 1. On the sphere, the pixels cover a solid angle ΔΩ_jk  sin(θ_j) Δθ Δϕ, i.e. the pixels' physical size approaches zero towards the poles.\n\nSee also equidistant cylindrical projection\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Abstract-Pixelization-Interface","page":"API Reference","title":"Abstract Pixelization Interface","text":"","category":"section"},{"location":"lib/public/","page":"API Reference","title":"API Reference","text":"The following functions and types are considered part of the public interface, though they are unlikely to be used unless you are implementing a new pixelization.","category":"page"},{"location":"lib/public/","page":"API Reference","title":"API Reference","text":"AbstractRingPixelization\nRing\nrings\nnring\nnpix\nnϕmax\nbuffer","category":"page"},{"location":"lib/public/#SphericalHarmonicTransforms.AbstractRingPixelization","page":"API Reference","title":"SphericalHarmonicTransforms.AbstractRingPixelization","text":"abstract type AbstractRingPixelization{R} end\n\nAbstract supertype of all ring map descriptor types.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SphericalHarmonicTransforms.Ring","page":"API Reference","title":"SphericalHarmonicTransforms.Ring","text":"Ring{R<:Real}\n\nParameters required to describe an isolatitude ring on the sphere compatible with spherical harmonic transforms.\n\nFields\n\noffset::Tuple{Int, Int}: Offsets (1-indexed) to the first pixel of the isolatitude ring(s) within a map array. The first offset in the tuple corresponds to the colatitude θ given by .cosθ, while the second offset is for the ring mirrored over the equator (colatitude π - θ). Either offset may be 0 to indicate the ring is not present (such as for the equator, but also partial sphere coverage such as transforms on bands).\nstride::Int: Stride between pixels within the ring.\nnϕ::Int: The number of equispaced pixels in the isolatitude ring.\ncosθ::R: Cosine of the colatitude of the ring, i.e. cos(θ).\nϕ₀_π::R: Azimuth of the first pixel in the isolatitude ring ϕ₀ divided by π.\nΔΩ::R: Solid angle area of pixels in the ring, roughly sin(θ)  Δθ  Δϕ.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SphericalHarmonicTransforms.rings","page":"API Reference","title":"SphericalHarmonicTransforms.rings","text":"rr = rings(ringpix::AbstractRingPixelization)\n\nA vector (or iterable) rr of Rings described by ringpix.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SphericalHarmonicTransforms.nring","page":"API Reference","title":"SphericalHarmonicTransforms.nring","text":"nr = nring(ringpix::AbstractRingPixelization)\n\nNumber of isolatitude rings nr described by ringpix.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SphericalHarmonicTransforms.npix","page":"API Reference","title":"SphericalHarmonicTransforms.npix","text":"np = npix(ringpix::AbstractRingPixelization)\n\nNumber of pixels np covered by all rings described by ringpix.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SphericalHarmonicTransforms.nϕmax","page":"API Reference","title":"SphericalHarmonicTransforms.nϕmax","text":"n = nϕmax(ringpix::AbstractRingPixelization)\n\nNumber of pixels n in the longest isolatitude ring described by ringpix.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SphericalHarmonicTransforms.buffer","page":"API Reference","title":"SphericalHarmonicTransforms.buffer","text":"mapbuf = buffer(ringpix::AbstractRingPixelization, ::Type{T})\n\nAllocates an array mapbuf with element type T appropriate for containing a map in the pixelization scheme described by ringpix.\n\n\n\n\n\n","category":"function"},{"location":"#SphericalHarmonicTransforms.jl-Documentation","page":"SphericalHarmonicTransforms.jl Documentation","title":"SphericalHarmonicTransforms.jl Documentation","text":"","category":"section"},{"location":"#User-Manual-and-Documentation","page":"SphericalHarmonicTransforms.jl Documentation","title":"User Manual and Documentation","text":"","category":"section"},{"location":"","page":"SphericalHarmonicTransforms.jl Documentation","title":"SphericalHarmonicTransforms.jl Documentation","text":"Pages = [\n    \"man/intro.md\",\n    \"man/usage.md\",\n    \"man/devdocs.md\",\n    \"man/references.md\"\n]\nDepth = 1","category":"page"},{"location":"#Library-API-Reference","page":"SphericalHarmonicTransforms.jl Documentation","title":"Library API Reference","text":"","category":"section"},{"location":"","page":"SphericalHarmonicTransforms.jl Documentation","title":"SphericalHarmonicTransforms.jl Documentation","text":"Pages = [\n    \"lib/public.md\"\n]\nDepth = 1","category":"page"},{"location":"#main-index","page":"SphericalHarmonicTransforms.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"SphericalHarmonicTransforms.jl Documentation","title":"SphericalHarmonicTransforms.jl Documentation","text":"Pages = [\"lib/public.md\"]","category":"page"},{"location":"man/references/#References","page":"Literature/References","title":"References","text":"","category":"section"},{"location":"man/references/#bib-spharms","page":"Literature/References","title":"Spherical Harmonics","text":"","category":"section"},{"location":"man/references/","page":"Literature/References","title":"Literature/References","text":"M. Abramowitz and I. A. Stegun, eds. Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables. Applied Mathematics Series 55. Washington, D.C.: U.S. Government Printing Office, June 1964. 10th printing, Dec 1972, with corrections.\nM. Gräf, S. Kunis, D. Potts. “On the computation of nonnegative quadrature weights on the sphere” In: Applied and Computational Harmonic Analysis, 27. (Jul 2009) DOI: 10.1016/j.acha.2008.12.003\nJ. D. Jackson. Classical Electrodynamics. 3rd ed. John Wiley & Sons, Inc., 1999. ISBN: 978-0-471-30932-1\nM. Reinecke and D.S. Seljebotn. “Libsharp - spherical harmonic transforms revisited”. In: Astron. & Astrophy. 554, (Jun 2013) ADS: 2013A&A…554A.112R\nR. Stompor. “S2HAT: Scalable Spherical Harmonic Transform Library”. (Oct 2011) ADS: 2011ascl.soft10013S","category":"page"},{"location":"man/references/#Blog-series","page":"Literature/References","title":"Blog series","text":"","category":"section"},{"location":"man/references/","page":"Literature/References","title":"Literature/References","text":"Notes on Calculating the Spherical Harmonics (Spherical Harmonics Series, Part I)\nMore Notes on Calculating the Spherical Harmonics: Analysis of maps to harmonic coefficients (Spherical Harmonics Series, Part II)\nSpherical Harmonic Transforms on Ring-based Pixelizations (Spherical Harmonics Series, Part III)\nSolving for Spherical Harmonic Analysis Quadrature Weights (Spherical Harmonics Series, Part IV)","category":"page"},{"location":"man/references/#Other","page":"Literature/References","title":"Other","text":"","category":"section"},{"location":"man/references/","page":"Literature/References","title":"Literature/References","text":"R. Shewchuk “An Introduction to the Conjugate Gradient Method Without the Agonizing Pain” (1994) URL: https://www.cs.cmu.edu/~jrs/jrspapers.html","category":"page"},{"location":"man/usage/#usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"CurrentModule = SphericalHarmonicTransforms","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"Pages = [\"usage.md\"]\nDepth = 2","category":"page"},{"location":"man/usage/#Getting-Started","page":"Usage","title":"Getting Started","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"This library is not registered in Julia's General registry, so the package must be installed either by cloning it directly:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"(@v1.7) pkg> add https://github.com/jmert/SphericalHarmonicTransforms.jl","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"or by making use of my personal registry","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"(@v1.7) pkg> registry add https://github.com/jmert/Registry.jl\n\n(@v1.7) pkg> add SphericalHarmonicTransforms","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"After installing, just load like any other Julia package:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"julia> using SphericalHarmonicTransforms","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"SphericalHarmonicTransforms exports only a couple of functions from its public interface: pairs of functions for spherical harmonic transform synthesis (synthesize/synthesize!) and analysis (analyze/analyze!).","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"To access other portions of the public API, the bindings must be referred to by full name or imported into the local scope.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"tip: Tip\nOn Julia v1.6 or newer, you can abbreviate SphericalHarmonicTransforms as SHT with the new import ... as ... syntax:julia> import SphericalHarmonicTransforms as SHT","category":"page"},{"location":"man/usage/#Performing-Transforms","page":"Usage","title":"Performing Transforms","text":"","category":"section"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"using SphericalHarmonicTransforms\nconst SHT = SphericalHarmonicTransforms","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"note: Note\nSee the Developer Docs for more details on implementing support for other pixelizations.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The only built-in pixelization is for an equidistant cylindrical projection (ECP), represented by an instance of an ECPPixelization structure. The constructor takes at least the number of pixels in the colatitude and azimuth directions, and optionally an element type as a type parameter which defaults to Float64. (The type parameter is used to determine the element type of newly allocated output arrays.)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"pix = SHT.ECPPixelization(50, 100) # == SHT.ECPPixelization{Float64}(50, 100)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"The object pix describes an array which corresponds to a column-major ordered Float64 matrix of size 50 × 100 that covers the sphere with pixels that are spaced uniformly in latitude and longitude.","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"With the pixelization described, a set of spherical harmonic coefficients a_ℓm can be synthesized to form a map using synthesize. For example, we can draw the real part of the quadrupole moment a_20:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"alm = zeros(ComplexF64, 3, 3); alm[3, 1] = 1;  # 1-indexed array for 0-indexed quantity\nquad = synthesize(pix, alm)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"and likewise we can (approximately) analyze the rendered map back to spherical harmonic coefficients with analyze:","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"analyze(pix, quad, #=lmax=# 5)","category":"page"},{"location":"man/usage/","page":"Usage","title":"Usage","text":"warning: Warning\nThe analysis transform is defined mathematically as an integral, but the operation demonstrated here is a finite sum over a discrete map. This is the reason for seeing non-zero values in the a_00 and a_40 terms, which is due in part to the very low resolution of the grid being used. While higher resolutions will decrease the severity of this effect, care needs to be used when performing spherical harmonic transforms since analysis does not inherently recover input synthesis coefficients (which is notably unlike the discrete Fourier transform).","category":"page"}]
}
