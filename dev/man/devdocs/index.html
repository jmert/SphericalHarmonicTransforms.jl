<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developer Documentation · Spherical Harmonic Transforms</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Spherical Harmonic Transforms</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SphericalHarmonicTransforms.jl Documentation</a></li><li><span class="tocitem">Spherical Harmonic Transforms</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li class="is-active"><a class="tocitem" href>Developer Documentation</a><ul class="internal"><li><a class="tocitem" href="#pixelnew"><span>Adding New Pixelizations</span></a></li></ul></li><li><a class="tocitem" href="../references/">Literature/References</a></li></ul></li><li><a class="tocitem" href="../../lib/public/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Spherical Harmonic Transforms</a></li><li class="is-active"><a href>Developer Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developer Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmert/SphericalHarmonicTransforms.jl/blob/master/docs/src/man/devdocs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Developer-Documentation"><a class="docs-heading-anchor" href="#Developer-Documentation">Developer Documentation</a><a id="Developer-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-Documentation" title="Permalink"></a></h1><ul><li><a href="#Developer-Documentation">Developer Documentation</a></li><li class="no-marker"><ul><li><a href="#pixelnew">Adding New Pixelizations</a></li></ul></li></ul><h2 id="pixelnew"><a class="docs-heading-anchor" href="#pixelnew">Adding New Pixelizations</a><a id="pixelnew-1"></a><a class="docs-heading-anchor-permalink" href="#pixelnew" title="Permalink"></a></h2><h3 id="pixelproperties"><a class="docs-heading-anchor" href="#pixelproperties">Necessary Properties of Ring-based Pixelizations</a><a id="pixelproperties-1"></a><a class="docs-heading-anchor-permalink" href="#pixelproperties" title="Permalink"></a></h3><p>As the name &quot;ring-based pixelizations&quot; suggests, the first obvious requirement for supported pixelization schemes is that the format be describable in terms of isolatitude rings. This restriction greatly reduces the number of times the associated Legendre polynomials must be calculated — from (in principle) every pixel if they all have a unique latitude to only once per isolatitude ring. Therefore, the first per-ring parameter we must be told is the colatitude <span>$\theta$</span> of each ring.</p><p>The second requirement is that each isolatitude ring&#39;s pixels meet the necessary conditions for the Fast Fourier Transform (FFT) to be used — namely, the pixels in azimuth are uniformly spaced and span (exactly) a full <span>$2\pi$</span> radians. These conditions are met when the azimuth coordinates are at locations <span>$\phi_k = \phi_0 + 2\pi k / N_\phi$</span> (for integer index <span>$k = [0, 1, \ldots, N_\phi - 1]$</span>), and therefore two additional parameters must be given: the number of pixels within the ring <span>$N_\phi$</span> and the azimuth offset of the first pixel in the ring <span>$\phi_0$</span>. For numerical efficiency and accuracy reasons, we will instead use the azimuth offset divided by pi: <span>$\phi_0/\pi$</span>.</p><p>These three parameters (<span>$\theta$</span>, <span>$N_\phi$</span>, <span>$\phi_0$</span>) are sufficient for implementing the synthesis transform of a single isolatitude ring. For the analysis transform, though, we also require the integration <a href="https://en.wikipedia.org/wiki/Volume_element">volume element</a> <span>$d\Omega \equiv \sin\theta \, d\theta \, d\phi$</span>, or rather its finite approximation <span>$\Delta\Omega \approx \sin\theta \, \Delta\theta \, \Delta\phi$</span>. Taking the volume element <span>$\Delta\Omega$</span> as a required parameter, the quantity <span>$\sin\theta$</span> is never calculated explicitly; instead only <span>$\cos\theta$</span> is used as the argument of the associated Legendre polynomials, so we can actually also revise the first parameter to instead be the cosine of the colatitude angle <span>$\cos\theta$</span>.</p><p>Together, this gives us 4 parameters which are required to sufficiently describe the geometry of an isolatitude ring so that we can perform spherical harmonic transforms on it:</p><ol><li>The cosine of the ring&#39;s colatitude angle: <span>$\cos\theta$</span></li><li>The azimuth angle, divided by <span>$\pi$</span>, of the first pixel in the ring: <span>$\phi_0/\pi$</span></li><li>The number of pixels equally spaced in azimuth within the ring: <span>$N_\phi$</span></li><li>The surface area of each pixel within the ring: <span>$\Delta\Omega$</span></li></ol><p>What remains is to describe how multiple rings are assembled into a map that covers the sphere, and here again the ECP grid proves a useful case study. The ECP grid maps well to a matrix (2D array, where colatitude increases across rows and azimuth across columns), but there is an inherent ambiguity in whether the ordering of the matrix in memory is <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row-major or column-major</a>. If we choose one — say column-major order, consistent with <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-column-major">Julia&#39;s matrix representation</a> — then the contents of a given isolatitude ring are non-contiguous in memory. One option would be to require that the transpose of the ECP map matrix be used (so that a ring is a contiguous vector of elements), but another more flexible option is to instead make the <a href="https://en.wikipedia.org/wiki/Stride_of_an_array">stride</a> <span>$s$</span> of the array an additional ring description parameter. When paired with offset of the first pixel in the ring <span>$o$</span>, we have sufficient information to completely describe an ECP grid in either row- or column-major order.</p><p>As one final optimization, though, recall that if the pixel grid is symmetric over the equator, then rings are best considered in <em>pairs</em>, since the associated Legendre polynomials are the same up to a negative sign for colatitude angles <span>$\theta$ and $\pi - \theta$</span>. If we replace the single parameter <span>$o$</span> with a tuple of parameters <span>$(o_1, o_2)$</span>, we can inform our implementation explicitly whether the ring-pair optimization applies (such as for a north-south pair of rings) or not (like for the singular equatorial row) by encoding either two or one valid indices in the tuple, respectively.</p><p>Finally, we add these three additional parameters to the above list:</p><ol><li>Offset to the first pixel in the northern- and southern-hemisphere rings, respectively (if valid): <span>$(o_1, o_2)$</span></li><li>The stride across the map array between successive pixels within the ring: <span>$s$</span></li></ol><h3 id="pixelinterface"><a class="docs-heading-anchor" href="#pixelinterface">Pixelization Interface</a><a id="pixelinterface-1"></a><a class="docs-heading-anchor-permalink" href="#pixelinterface" title="Permalink"></a></h3><p><strong>Required</strong></p><table><tr><th style="text-align: left">Interfaces to extend/implement</th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><a href="../../lib/public/#SphericalHarmonicTransforms.AbstractRingPixelization"><code>AbstractRingPixelization</code></a></td><td style="text-align: left">Supertype of ring-based map pixelizations</td></tr><tr><td style="text-align: left"><a href="../../lib/public/#SphericalHarmonicTransforms.rings"><code>rings()</code></a></td><td style="text-align: left">Returns an indexable container of <a href="../../lib/public/#SphericalHarmonicTransforms.Ring"><code>Ring</code></a> descriptions for each ring in the described map</td></tr></table><p><strong>Optional Overrides</strong></p><p>The following functions have a generic implementation which deduces the necessary values by inspecting every ring (returned by <a href="../../lib/public/#SphericalHarmonicTransforms.rings"><code>rings</code></a>), but a particular pixelization is encouraged to specialize these if they can be calculated more efficiently using structural knowledge of the pixelization.</p><table><tr><th style="text-align: left">Interfaces to extend/implement</th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><a href="../../lib/public/#SphericalHarmonicTransforms.buffer"><code>buffer()</code></a></td><td style="text-align: left">Returns an array compatible with storing a map described by a given ring pixelization</td></tr><tr><td style="text-align: left"><a href="../../lib/public/#SphericalHarmonicTransforms.nring"><code>nring()</code></a></td><td style="text-align: left">The number of isolatitude rings in the pixelization</td></tr><tr><td style="text-align: left"><a href="../../lib/public/#SphericalHarmonicTransforms.npix"><code>npix()</code></a></td><td style="text-align: left">The total number of pixels in the pixelization</td></tr><tr><td style="text-align: left"><a href="../../lib/public/#SphericalHarmonicTransforms.nϕmax"><code>nϕmax()</code></a></td><td style="text-align: left">The number of pixels in the longest isolatitude ring in the pixelization</td></tr></table><h3 id="pixelexample"><a class="docs-heading-anchor" href="#pixelexample">Example Implementation</a><a id="pixelexample-1"></a><a class="docs-heading-anchor-permalink" href="#pixelexample" title="Permalink"></a></h3><p>The built-in ECP pixelization does not support exact quadrature on the sphere, but it is included because the axes are uniformly sampled (so the maps are easily represented as matrices without any special handling) and the simplicity of its implementation. For more than trivial or example cases, though, it is very likely that another pixelization scheme will be required.</p><p>A well-known improvement is to modify the ECP grid to permit non-uniformly sampled points in <span>$\theta$</span>, with the node locations (and weights, see below) corresponding to the <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_quadrature">Gauss-Legendre nodes</a>. In this section, we will demonstrate implementing support for spherical harmonic transforms on the the Gauss-Legendre (GL) pixelization. Computation of the Gauss-Legendre nodes and weights is provided by <a href="https://github.com/JuliaApproximation/FastGaussQuadrature.jl"><code>FastGaussQuadrature.jl</code></a>.</p><p>The first step is to import the <a href="#pixelinterface">interface</a> types. The new <code>GLPixelization</code> type must be a subclass of the <code>AbstractRingPixelization</code>, where the type parameter <code>R</code> is the nominal element type used during the transform.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import SphericalHarmonicTransforms: AbstractRingPixelization, Ring,
               rings, buffer, nring, npix, nϕmax</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct GLPixelization{R} &lt;: AbstractRingPixelization{R}
           nθ::Int
           nϕ::Int
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; GLPixelization(nθ, nϕ) = GLPixelization{Float64}(nθ, nϕ)</code><code class="nohighlight hljs ansi" style="display:block;">Main.GLPixelization</code></pre><p>Then, the only other <strong>required</strong> step is to implement a specialization of the <a href="../../lib/public/#SphericalHarmonicTransforms.rings"><code>rings</code></a> method to return a vector of <a href="../../lib/public/#SphericalHarmonicTransforms.Ring"><code>Ring</code></a> structures that describe the <a href="#pixelproperties">properties of the ring</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using FastGaussQuadrature: gausslegendre</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function rings(glpix::GLPixelization{R}) where {R}
           nθ, nϕ = glpix.nθ, glpix.nϕ
           nθh = (nθ + 1) ÷ 2  # number of rings in N. hemisphere + equator (if nθ is odd)
           ϕ_π = one(R) / nϕ   # constant pixel offset for all rings
           Δϕ = 2R(π) / nϕ     # constant azimuthal pixel size for all rings
           stride = nθ         # constant stride, column-major ordering
           cθ, sθΔθ = gausslegendre(nθ)  # z = cos(θ) and corresponding weights
           # z ∈ [-1, 1] and θ ∈ [0, π] run in opposite directions, but cos(θ) == -z
           cθ = -cθ[1:nθh]
           sθΔθ = sθΔθ[1:nθh]
           rings = Vector{Ring}(undef, nθh)
           for ii in 1:nθh
               o₁ = ii           # northern-ring offset
               o₂ = nθ - ii + 1  # southern-ring offset
               offs = (o₁, o₁ == o₂ ? 0 : o₂)  # pairs, except if both aligned with equator
               rings[ii] = Ring(offs, stride, nϕ, cθ[ii], ϕ_π, sθΔθ[ii] * Δϕ)
           end
           return rings
       end</code><code class="nohighlight hljs ansi" style="display:block;">rings (generic function with 3 methods)</code></pre><p>With just <code>rings</code> implemented, generic methods will then calculate other necessary parameters by inspecting the ring list.</p><p>For example, we can observe that the Gauss-Legendre grid has better properties with respect to the finite integration when compared to the ECP grid.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; alms = zeros(ComplexF64, 6, 6); alms[3, 1] = 1;  # a_{20} = 1</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ecppix, glpix = ECPPixelization(50, 100), GLPixelization(50, 100);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ecpmap, glmap = synthesize(ecppix, alms), synthesize(glpix, alms);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analyze(ecppix, ecpmap, #=lmax=# 5)</code><code class="nohighlight hljs ansi" style="display:block;">6×6 Matrix{ComplexF64}:
 0.000368242+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
         0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
     1.00082+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
         0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
  0.00110856+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
         0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; analyze(glpix, glmap, #=lmax=# 5)</code><code class="nohighlight hljs ansi" style="display:block;">6×6 Matrix{ComplexF64}:
 6.38378e-16+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
         0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
         1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
         0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 1.11022e-15+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
         0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im</code></pre><p>Notice that the ECP grid analysis &quot;leaks&quot; power into neighboring spherical harmonic coefficients, but the GL grid almost exactly recovers the input coefficients.</p><p>Returning to the optional components of abstract pixelization interface, compare the shapes of the two maps created above:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; size(ecpmap)</code><code class="nohighlight hljs ansi" style="display:block;">(50, 100)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; size(glmap)</code><code class="nohighlight hljs ansi" style="display:block;">(5000,)</code></pre><p>Like the ECP grid, it may be preferable to conceptualize and represent the GL grid as a matrix rather than a vector. (Fundamentally, the <em>shape</em> of the array is immaterial to <code>synthesize</code> and <code>analyze</code>, as long as the described ring pixelization is within bounds of the array&#39;s linear indices.) Overloading the <a href="../../lib/public/#SphericalHarmonicTransforms.buffer"><code>buffer</code></a> function provides a mechanism to allocate the synthesize map with a preferred shape:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function buffer(glpix::GLPixelization, ::Type{T}) where {T}
           return Matrix{T}(undef, glpix.nθ, glpix.nϕ)
       end</code><code class="nohighlight hljs ansi" style="display:block;">buffer (generic function with 4 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; size(synthesize(glpix, alms))</code><code class="nohighlight hljs ansi" style="display:block;">(50, 100)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Be sure to overload the 2-argument method which explicitly takes the descired element type. The 1-argument method will forward the pixelization&#39;s type parameter as the second argument if necessary.</p></div></div><p>The other reason to implement specializations of the <a href="#pixelinterface">optional interface</a> is that generic methods infer the necessary pixelization properties by iterating through the list of all rings and extracting/calculating the relevant quantites. We can see this quite obviously as memory allocations when running these functions, despite the grid size alone provides all the necessary information (and therefore should not require actually allocating the rings vector):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; (nring(glpix), npix(glpix), nϕmax(glpix)); # warmup</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time (nring(glpix), npix(glpix), nϕmax(glpix))</code><code class="nohighlight hljs ansi" style="display:block;">  0.000133 seconds (203 allocations: 26.625 KiB)
(50, 5000, 100)</code></pre><p>By overloading specializations for the <code>GLPixelization</code> type,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; nring(glpix::GLPixelization) = glpix.nθ</code><code class="nohighlight hljs ansi" style="display:block;">nring (generic function with 3 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; npix(glpix::GLPixelization) = glpix.nθ * glpix.nϕ</code><code class="nohighlight hljs ansi" style="display:block;">npix (generic function with 3 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nϕmax(glpix::GLPixelization) = glpix.nϕ</code><code class="nohighlight hljs ansi" style="display:block;">nϕmax (generic function with 3 methods)</code></pre><p>we can avoid such unnecessary computation and allocation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; (nring(glpix), npix(glpix), nϕmax(glpix)); # warmup</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @time (npix(glpix), nϕmax(glpix))</code><code class="nohighlight hljs ansi" style="display:block;">  0.000007 seconds (2 allocations: 48 bytes)
(5000, 100)</code></pre><p>(where the remaining allocation is due to the returned tuple of values).</p><h3 id="Testing-new-pixelizations"><a class="docs-heading-anchor" href="#Testing-new-pixelizations">Testing new pixelizations</a><a id="Testing-new-pixelizations-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-new-pixelizations" title="Permalink"></a></h3><p>This package provides a minor test suite to automate checking various aspects of the implementation of a new pixelization.</p><p>The test suite requires direct access to several underlying implementation packages, so the following packages must also be included as direct dependencies in your test project:</p><ul><li>AssociatedLegendrePolynomials</li><li>FFTW</li><li>SphericalHarmonicTransforms</li></ul><p>Then, include the test suite from this package&#39;s source directory with:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import SphericalHarmonicTransforms</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; include(joinpath(dirname(pathof(SphericalHarmonicTransforms)), &quot;..&quot;, &quot;test&quot;, &quot;testsuite.jl&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">Main.TestSuite</code></pre><p>which creates a new <code>TestSuite</code> module in the current scope.</p><p>Tests are run against an instance of the pixelization by the <code>TestSuite.runtests</code> function:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # even dimensions
       TestSuite.runtests(GLPixelization(50, 100))</code><code class="nohighlight hljs ansi" style="display:block;">Test Summary:                                                            | Pass  Total
Test Suite - Main.GLPixelization{Float64} |   48     48</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # odd dimensions
       TestSuite.runtests(GLPixelization(51, 101), rtol = 1e-6)</code><code class="nohighlight hljs ansi" style="display:block;">Test Summary:                                                            | Pass  Total
Test Suite - Main.GLPixelization{Float64} |   48     48</code></pre><p>The second line above shows that an optional relative tolerance may be provided by which approximate equality is judged when comparing synthesis and analysis of the new pixelization against a reference implementation.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/">« Usage</a><a class="docs-footer-nextpage" href="../references/">Literature/References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Saturday 30 July 2022 22:06">Saturday 30 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
